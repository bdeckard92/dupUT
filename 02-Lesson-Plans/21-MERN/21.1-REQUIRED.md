# Module 21 Virtual Class: MERN

## Overview 

In today's virtual class, students will practice GraphQL queries and mutations.

## Learning Objectives

By the end of class, students will be able to:

* Write queries using the GraphQL query language.

* Use mutations to modify server-side data.

## Instructor Notes

* Be sure to prepare and read over the activities before your class begins. Try to anticipate any questions students may have. 

* Today's activities rely on the GraphQL Playground. Students do not need to install a separate tool to access this technology. To use the GraphQL Playground, simply start the app using `npm install`, `npm run seed`, and `npm start`and point to `localhost:3001/graphql` in the browser.

* The GraphQL activities and instructor demonstrations require a minimum npm version of 7.0.0 or greater. Prior to class, please be sure to check your npm version and update if needed. Refer to the [NPM docs on updating to latest stable version.](https://docs.npmjs.com/try-the-latest-stable-version-of-npm).

* For a refresher on how to use the GraphQL Playground, see the [Apollo Docs on GraphQL Playground](https://www.apollographql.com/docs/apollo-server/testing/graphql-playground/).

* For students who need help opening up the apps used in today's activities or accessing GraphQL Playground, step-by-step instructions are found in `02-Stu_Apollo-Server/README.md`.
* During activities, visit a few breakout rooms quietly and ask the group if they are comfortable with the activity and provide gentle tips to keep them on track.

* GraphQL Schema was covered in Lesson 1, and JWT was covered in Lesson 2.

## Time Tracker 

| Start  | #  | Activity Name                       | Duration |
|---     |--- |---                                  |---       |
| 6:30PM | 0  | Office Hours                        | 0:30     |
| 7:00PM | 1  | Everyone Do: Career Connection      | 0:20     |
| 7:20PM | 2  | Instructor Do: Student Check-In     | 0:05     |
| 7:25PM | 3  | Instructor Demo: Query Arguments    | 0:05     |
| 7:30PM | 4  | Student Do: GraphQL Query Arguments | 0:15     |
| 7:45PM | 5  | Instructor Review: Query Arguments  | 0:10     |
| 7:55PM | 6  | Instructor Demo: Mutations          | 0:05     |
| 8:00PM | 7  | Student Do: Mutations               | 0:15     |
| 8:15PM | 8  | Instructor Review: Mutations        | 0:10     |
| 8:25PM | 9  | Recap                               | 0:05     |
| 8:30PM | 10 | Challenge Review                    | 0:30     |
| 9:00PM | 11 | End                                 | N/A      |
---

## Class Instructions 

### 1. Everyone Do: Career Connection (20 min)

* Welcome students to class.

* Invite students to post questions in the Zoom chat so TAs and/or the instructor can address them at the end of class.

* Open the lesson's [slide deck](https://docs.google.com/presentation/d/1P8vSht6Vrp4Dljj3QEkvf8LPNSGAUAjUjnSFE9s5Rbk/edit?usp=sharing) and walk through the following slides on foundation setting: 

    **Big Picture**: This is an opportunity to look at the big picture of where students are in the course. Take a moment to discuss a few real-world examples of why this week's topics are valuable.

    **Boot Camp Pointers**: Review some logistics that will help students stay on track. This is an opportunity to speak to what students might need at this particular point in the course. 

    **This Week**: Review the key skills students will be learning this week. 

    **This Week's Assignment**: Give a quick summary of this week's Challenge assignment and describe how the skills they learn throughout the week will be applied to it.

    **Career Connection**: Reinforce that students will use the skills they learn this week throughout their careers. It's important for them to know the "why" and "how" behind the "what." Give examples of how these skills are used on the job. If you feel comfortable, share examples of how you have used them in your professional career.

    * Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):

        * ‚òù Last week, we talked briefly about learning React and the fact that many of the skills are transferrable to Vue or Angular. As such, you should apply to those jobs too! The same principle can be applied to the MERN stack. Can you think of some other common coding stacks?

        * üôã Each component of the so-called MERN stack can be switched out for different technologies that do similar things&mdash;such as using a different database like MySQL instead of MongoDB, or using Python and Flask instead of Node and Express. For each component, the skills are often transferrable.  

    * Encourage students to consider applying widely to jobs even if they haven't learned all the skills in a job posting. When looking at a job posting, students can consider jobs that fall within the following parameters:

        * Require up to 2&ndash;3 years of experience (these positions will often hire entry-level with zero experience)

        * Require technologies that are similar to what we teach

        * Students are familiar with 40&ndash;50% of the technologies listed.

    * Remind students that a list of technologies on a job posting is merely a wish list&mdash;most companies know they won't get everything on it.

    **How to Succeed This Week**: Remind students that they might experience moments of frustration as they learn complex concepts and tools, and that these times are actually proven opportunities to deepen knowledge. Consider sharing something about your personal learning journey. This helps students recognize that everyone starts somewhere and that they are not alone.

    **Today's Objectives**: Outline the concepts that will be covered in today's lesson. Remind students that they can find the relevant activity files in the "Getting Ready for Class" page in their course content. 

### 2. Instructor Do: Student Check-In (5 min)

* Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):

  * ‚òùÔ∏è How are you feeling about your progress so far?

  * üôã We are adding another layer to our full-stack skill set. It's important to look back at what we've accomplished and acknowledge that it is a lot! It‚Äôs also okay to feel overwhelmed&mdash;as long as you don‚Äôt give up.

  * ‚òùÔ∏è How comfortable do you feel with this topic?

  * üôã Let's do Fist to Five together. If you are not feeling confident, hold up a fist (0). If you feel very confident, hold up an open hand (5).

### 3. Instructor Demo: Query Arguments (5 min) 

* Navigate to `01-Query-Arguments/Solved` in your command line and run `npm install` and `npm run seed`. 

* If everything is installed and seeded correctly, run `npm run watch` and open your browser to <http://localhost:3001/graphql> to view the GraphQL Playground and demonstrate the following:

* Open `localhost:3001/graphql` in your browser and demonstrate the following: 

  * üîë We use the `classes` entry point to query all the `Class` objects using the field `name` and `_id`. This will give us a list of the the names and ids for all of the classes:

     ```gql
     query getAllClassIdNames {
       classes {
         name
         _id
       }
     }
     ```

  * We copy one of the ids returned:

     ```json
     "_id": "Copy_This_ID"
     ```

  * In the Query Variables pane, we give the value of the `id` variable the value of the id that we just copied, and we make sure that both `id` and the id that we just copied are surrounded by quotes:

     ```json
     {"id" : "Add_Copied_ID_Here"}
     ```

  * We enter the provided query using a variable into the query editor:

     ```gql
     query class($id: ID!) {
       class(id: $id) {
         name
         professor {
           name
         }
       }
     }
     ```

  * We click the Play button. If our resolver is successful, both the class and professor's name will be fetched.


* Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):

    * ‚òùÔ∏è Where have we used this before?

    * üôã In Lesson 1, we set up the `typeDefs` and `resolvers` for the `Thought` and `Users` models.

    * ‚òùÔ∏è How does this activity equip us for the Challenge?

    * üôã We will be using GraphQL for our Challenge, so we need to know how to create schemas for our models.

    * ‚òùÔ∏è How would we build this?

    * üôã We need to create type definitions for the `User` and `Query` data types, and we need to create a resolver for the `Query` for all `User`s.

* Answer any questions before proceeding to the next activity.

### 4. Student Do: GraphQL Schema (15 min) 

* Divide students into breakout rooms.

* Direct students to the activity instructions found in `01-GraphQL-Schema/README.md`, which are also shown here:

     ```md
     # GraphQL Schema

     In this activity, you will create a schema for users for a GraphQL API.

     ## Instructions

     * Navigate to [Unsolved](Unsolved/) in your command line and run `npm install` and `npm run seed`.

     * Check out the [User.js](Unsolved/models/User.js) file for the `User` model. You will need to know these fields to create type definitions for the `User` data type.

     * Create a folder called `schemas` with three files in it: `typeDefs.js`, `resolvers.js`, and `index.js`

         * In `typeDefs.js`, create type definitions for the `User` and `Query` data type.

         * For `User`, include the same fields that were defined in the Mongoose `UserSchema` plus an `_id` field.

         * For `Query`, create a `users` query that will return an array of `User`s.

         * Remember to import the `gql` tagged template function from `apollo-server-express`!

         * In `resolvers.js`, create a `Query` for all `users`.

         * Perform a `.find()` method on the `User` model to get all users.

         * Remember to import the `User` model!

         * In `index.js`, connect the two files and export them.

     * To check if everything is working properly, run `npm run watch` in your command line and open your browser to <http://localhost:3001/graphql> to view the GraphQL Playground.

         * Test out the query for all users. For example, `query { users { name }}` should get you a list of all the users' names.

     * Press `CTRL + C` to stop the server before moving on to the next activity.

     ## Hint(s)

     * You can refer to the [Apollo Server Docs for Schemas](https://www.apollographql.com/docs/apollo-server/schema/schema/).

     ## Bonus

     * When querying users, omit the Mongoose-specific `__v` property and the user's password information.
     ```

### 5. Instructor Review: GraphQL Schema (10 min) 

* Bring students back from breakout rooms.

* Use the prompts and talking points (üîë) below to review the following key points:

  * ‚úîÔ∏è `args`

  * ‚úîÔ∏è `findById()`

  * ‚úîÔ∏è `populate()`

* Open `08-Stu_Query-Arguments/Solved/schemas/resolvers.js` in your IDE and explain the following: 

  * When we use a query with arguments, we create an object that holds the information we need to pass to our resolver.

  * üîë To have access to that object, our resolver function uses `args`.

  * Because `args` is the second of the positional parameters that the resolver can take, we list `args` second so it keeps its place:

     ```js
     class: async (parent, args) => {
     ```

  * üîë To return the data we need, we call the method `findById()` on the `Class` model we imported to read data from the MongoDB database. The `findById()` method is a built-in method on Mongoose models that allows us to easily search for a single method by `id`. Because we want the data in the `id`, we use `args.id`:

     ```js
     return await Class.findById(args.id);
     ```

  * üîë To access the related `Professor` object, we use `populate()`:

     ```js
     return await Class.findById(args.id).populate('professor');
     ```

* Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):

  * ‚òùÔ∏è How can we get more specific results using arguments? 

  * üôã Arguments allow us to query for more specific data by passing information from our query to our resolver. For example, we can search for a specific `id` by passing the information about that `id` to the resolver, which then can use that information to search the database for that specific object using that data.

  * ‚òùÔ∏è Why use variables in our queries? 

  * üôã Variables allow us to make our queries more durable. For example, by using a variable when searching by id, we only had to change the value of the variable to search for another object. If we didn't have variables, we would have to write a whole new query.

  * ‚òùÔ∏è What can we do if we don't completely understand this?

    * üôã We can refer to Lesson 1, read the [Apollo docs on handling arguments](https://www.apollographql.com/docs/apollo-server/data/resolvers/#handling-arguments), and stay for Office Hours to ask for help.

* Answer any questions before proceeding to the next activity.

### 6. Instructor Demo: Mutations (5 min) 

* Open `02-Mutations/Solved/schemas/typedefs.js` in your IDE and explain the following:

  * GraphQL does more than retrieve existing data. We can also use GraphQL to write data as well.

  * üîë The mutation type is similar to the query type. However, instead of providing an entry point to read an object or objects, the mutation type provides an entry point to write an object or objects.

  * üîë We create an entry point `addSchool` and set the object that it will write to to be a `School` object.

  * üîë We also pass in arguments that define the fields that will be written. This information will be passed to the resolver.

     ```js
     type Mutation {
       addSchool(name: String!, location: String!, studentCount: Int!): School
       updateClass(id: ID!, building: String!): Class
     }
     ```


* Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):

  * ‚òùÔ∏è Where have we used this before?

    * üôã We implemented JWT to authenticate users in Lesson 2.

  * ‚òùÔ∏è How does this activity equip us for the Challenge?

    * üôã Our Challenge will also use JWT to login users.

  * ‚òùÔ∏è How would we build this?

    * üôã A mutation is way to write data using GraphQL. We use the mutation type to define the entry point to the data to be written and a mutation resolver to provide the functionality to write the data to our database.

* Answer any questions before proceeding to the next activity.

### 7. Student Do: Mutations (15 min) 

* Divide students into breakout rooms.

* Direct students to the activity instructions found in `02-JSON-Web-Token/README.md`, which are also shown here:

     ```md
     # JSON Web Token

     In this activity, you will implement JSON Web Tokens as a way to authenticate a user logging in.

     ## Instructions

     * Navigate to [Unsolved](Unsolved/) in your command line and run `npm install`.

     * Create a folder called `utils` with a new file called `auth.js`.

         * Require `jsonwebtoken` on top.

         * Create a JWT `secret` and an `expiration`.

         * Export the `signToken()` function that takes in a `user` object and adds the `email` and `_id` properties to the token, along with the `secret` and `expiration`.

     * Open [typeDefs.js](Unsolved/schemas/typeDefs.js) and define a new `Mutation` and `Auth` type.

         * Add a `login()` mutation that takes in an `email` and `password` and returns an `Auth` object.

         * Add a `Auth` type that must return a `token` and can include any other `user` data.

     * Open [resolvers.js](Unsolved/schemas/resolvers.js) and import the `signToken()` function on top.

         * Update the `login()` mutation to sign a `token` and return an object that combines the `token` with the user's data.

     * To check if everything is working properly, run `npm run watch` in your command line and open your browser to <http://localhost:3001/graphql> to view the GraphQL Playground.

         * Query all users for their `email` and `password`. For now, you should be able to see their passwords. Make note of one user's email and password to test out the `login()` mutation.

         * Open another tab in GraphQL Playground and test the `login()` mutation using the query variables `email` and `password` of the user noted above.

         * You should be able to see the `token` along with any other `user` data you included.

     * Press `CTRL + C` to stop the server before moving on to the next activity.

     ## Hint(s)

     * You can refer to the [Introduction to JSON Web Tokens Docs](https://jwt.io/introduction/).
     ```

### 8. Instructor Review: Mutation (10 min) 

* Bring students back from breakout rooms. 

* Use the prompts and talking points (üîë) below to review the following key points:

  * ‚úîÔ∏è `findOneAndUpdate()`

  * ‚úîÔ∏è `{new: true}`

* Open `10-Stu_Mutations/Solved/schemas/resolvers.js` in your IDE and explain the following: 

  * When your mutation is not working as expected, a great place to look is the resolver.

  * We have written a mutation to update the building for a specific class. However, it looks like when we run the mutation, the building is not being updated.

  * When your mutation is not working as expected, a great place to look is the resolver.

  *  Because we are using Mongoose, we must import the model to write data to MongoDB. It looks like we have imported the `Class` model successfully.

     ```js
     const { School, Class, Professor } = require('../models');
     ```

  *  We also need to make sure that our arguments are passed to the resolver. It looks like this is working too:

     ```js
     updateClass: async (parent, { id, building }) => {
     ```

  * üîë To write the data, we call the `.findOneAndUpdate()` method on the imported `Class` model and pass in the specific information needed to find the class by id and update the building:

     ```js
     return await Class.findOneAndUpdate(
       { _id: id }, 
       { building },
     }
     ```

  * üîë By default, the object returned will not be the one updated. To return the new object, we set `new` to be `true`. Adding this line will fix the bug in our resolver:

     ```js
     { new: true }
     ```

* Navigate to `10-Stu_Mutations/Solved` in your command line and run `npm install`, `npm run seed`, and `npm start`.

* Open `localhost:3001/graphql` in your browser and demonstrate the following: 

  * üîë We test if our resolver is now working by using an existing `Class` object id and adding the the provided test object to the Query Variable editor:

     ```json
       {
         "id": "<insert ID of a class here>",
         "building": "AA"
       }
       ```

  * üîë Next we run the provided mutation:

     ```gql
       mutation updateClass($id: ID!, $building: String!) {
         updateClass(id: $id, building: $building) {
           name
           building
         }
       }
     ```

  * The updated information should now be fetched.

* Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):

  * ‚òùÔ∏è How can we use mutations to create and update data? 

  * üôã We use the mutation type to define the entry point for the object we want to write or update. We write a mutation resolver that performs the task of creating or updating the data.

  * ‚òùÔ∏è What can we do if we don't completely understand this?

    * üôã We can refer to Lesson 2, read the [Introduction to JSON Web Tokens Docs](https://jwt.io/introduction/), and stay for Office Hours to ask for help.

* Answer any questions before proceeding.

### 9. Recap (5 min)

* Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):

  * ‚òùÔ∏è What topics did we cover today? What are the main takeaways?

    * üôã We covered the basics of GraphQL schemas and JWT.

  * ‚òùÔ∏è What do you think is okay to not completely understand?

    * üôã All of it! The field of web development is very wide and rapidly evolving. Unless you choose to specialize, it's not necessary to know any one area completely to be successful. 

  * ‚òùÔ∏è Why is it important to do as much of the lesson material before class as possible?

    * üôã It's important both to be fully prepared to start the Challenge and because it will prepare you for your future career as a web developer. We cover a lot of material in the boot camp. Lessons are intentionally designed to give each topic an optimal amount of depth and scope so that you have a solid foundation to build upon in future lessons. The skills you learn in the lessons are cutting-edge, real-world skills that you will use in your career as a full-stack web developer. 

    * ‚òùÔ∏è Where in the asynchronous lessons can you learn more?

    * üôã GraphQL schemas were covered in Lesson 1, and JWT in Lesson 2.

    * ‚òùÔ∏è What excites you about the remaining lessons for this week?

* Use student answers to transition to Office Hours.

### 10. Challenge Review (30 min)

* Take this time to help get students unblocked on the current Challenge that they are working through.

* Expect that students may ask for the following:

  * Further review on a particular subject

  * Debugging assistance

  * Help with computer issues

  * Guidance with a particular tool

### 11. End

How did today‚Äôs lesson go? Your feedback is important. Please take 5 minutes to complete [this anonymous survey](https://forms.gle/3LozVjherGH83aG17).

---
¬© 2021 Trilogy Education Services, LLC, a 2U, Inc. brand. Confidential and Proprietary. All Rights Reserved.
