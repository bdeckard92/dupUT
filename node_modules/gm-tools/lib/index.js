"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var gm = require("gm"),
    sameTime = require("same-time"),
    Pixel = require("pixel-class"),
    PNG = require("pngjs").PNG,
    iterateObject = require("iterate-object");

var GmParser = function () {
    /**
     * GmParser
     * Creates a new instance of `GmParser`.
     *
     * @name GmParser
     * @function
     * @param {String|Buffer|GraphicsMagick} input The path to an image file, the
     * image buffer or an existing GraphicsMagick object.
     * @param {Function} cb The callback function.
     */
    function GmParser(input, cb) {
        _classCallCheck(this, GmParser);

        this.input = input;

        if (input.constructor.name === "gm") {
            this.gm = input;
        } else {
            this.gm = gm(this.input);
        }

        this.getSize(cb);
        //iterateObject(this.gm.__proto__, (func, name) => {
        //    if (typeof func === "function") {
        //        this[name] = func.bind(this.gm);
        //    }
        //});
    }

    /**
     * resize
     * Resizes the image.
     *
     * @name resize
     * @function
     * @param {Number} width The size width.
     * @param {Number} height The size height.
     */


    _createClass(GmParser, [{
        key: "resize",
        value: function resize(width, height) {
            this.gm.resize.apply(this.gm, arguments);
        }

        /**
         * parse
         * Parses the image internally.
         *
         * @name parse
         * @function
         * @param {Function} cb The callback function.
         */

    }, {
        key: "parse",
        value: function parse(cb) {
            sameTime([this.toPNGBuffer.bind(this), this.getSize.bind(this)], cb);
        }

        /**
         * getSize
         * Gets the image size. This appends the `width` and `height` functions to
         * the `GmParser` instance that return the width and height of the image.
         *
         * @name getSize
         * @function
         * @param {Function} cb The callback function.
         */

    }, {
        key: "getSize",
        value: function getSize(cb) {
            var _this = this;

            cb = cb || function () {};
            this.gm.size(function (err, size) {
                if (err) {
                    return cb(err);
                }
                _this.size = size;
                _this.width = function () {
                    return size.width;
                };
                _this.height = function () {
                    return size.height;
                };
                cb(null, size);
            });
        }

        /**
         * toPNGBuffer
         * Converts the image into a buffer that is parsed by `pngjs`.
         *
         * @name toPNGBuffer
         * @function
         * @param {Function} cb The callback function.
         */

    }, {
        key: "toPNGBuffer",
        value: function toPNGBuffer(cb) {
            this.gm.toBuffer("PNG", function (err, buff) {
                if (err) {
                    return cb(err);
                }
                var str = new PNG();
                str.end(buff);
                str.on("parsed", function (b) {
                    return cb(null, b, buff);
                });
                str.on("error", cb);
            });
        }

        /**
         * pixels
         * Gets all the image pixels.
         *
         * @name pixels
         * @function
         * @param {Buffer} buffer An optional `pngjs` buffer. If provided, the pixels
         * array will be *returned*.
         * @param {Function} cb The callback function.
         * @returns {Array} An array of pixels (only if the `buffer` argument is provided).
         */

    }, {
        key: "pixels",
        value: function pixels(buffer, cb) {
            var _this2 = this;

            if (typeof buffer === "function") {
                cb = buffer;
                buffer = null;
                return this.parse(function (err, data) {
                    if (err) {
                        return cb(err);
                    }
                    var buffer = data[0];
                    _this2.pixels(buffer, cb);
                });
            }

            var pixels = [],
                size = this.size;

            for (var y = 0; y < size.height; ++y) {
                for (var x = 0; x < size.width; ++x) {
                    pixels.push(this.getPixel(x, y, buffer));
                }
            }

            if (cb) {
                cb(null, pixels);
            }

            return pixels;
        }

        /**
         * getPixel
         * Gets the pixel data at given coordinates.
         *
         * @name getPixel
         * @function
         * @param {Number} x The `x` coordinate.
         * @param {Number} y The `y` coordinate.
         * @param {Buffer} buffer An optional `pngjs` buffer. If provided, the
         * pixels array will be *returned*.
         * @param {Function} cb The callback function.
         * @returns {Pixel} A [`Pixel`](https://github.com/IonicaBizau/pixel-class)
         * instance. This will be returned only if the `buffer` argument is provided.
         */

    }, {
        key: "getPixel",
        value: function getPixel(x, y, buffer, cb) {
            var _this3 = this;

            if (typeof buffer === "function") {
                cb = buffer;
                return this.toPNGBuffer(function (err, pngBuffer) {
                    if (err) {
                        return cb(err);
                    }
                    _this3.getPixel(x, y, pngBuffer, cb);
                });
            }

            var idx = this.width() * y + x << 2,
                px = new Pixel(buffer[idx], buffer[idx + 1], buffer[idx + 2], buffer[idx + 3] / 255);

            if (cb) {
                cb(null, px);
            }

            return px;
        }
    }]);

    return GmParser;
}();

/**
 * gmTools
 * Friendly tools for interacting with graphicsmagick
 *
 * @name gmTools
 * @function
 * @param {String|Buffer|GraphicsMagick} input The path to an image file, the
 * image buffer or an existing GraphicsMagick object.
 * @param {Function} cb The callback function.
 * @return {GmParser} The `GmParser` instance.
 */


module.exports = function gmTools(input, cb) {
    return new GmParser(input, cb);
};